<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[揭开OKR (Objectives and Key Results) 的面纱]]></title>
    <url>%2Fposts%2F6eba1cd3.html</url>
    <content type="text"><![CDATA[什么是OKR – 摘自[百度百科]：OKR（Objectives and Key Results）即目标与关键成果法，是一套明确和跟踪目标及其完成情况的管理工具和方法，由英特尔公司发明。 OKR的主要目标是明确公司和团队的“目标”以及明确每个目标达成的可衡量的“关键结果”。一本关于OKR的书将OKR定义为“一个重要的思考框架与不断发展的学科，旨在确保员工共同工作，并集中精力做出可衡量的贡献。”OKR可以在整个组织中共享，这样团队就可以在整个组织中明确目标，帮助协调和集中精力。 OKR的基本原理OKR发展为一种标准化的目标管理方法，目标用来明确方向，关键结果则用来量化目标，使团队聚焦在一个有挑战性的目标上。目标设定的是一段时间的目标，通常为一个季度；关键结果用来判定到期时目标是否达成。 OKR的组成要素Objectives:（目标） 有野心的，较激进的 令人感觉紧张而不舒适的 Key Results:（关键结果） 明确的使Objective可实现 可量化 导向Objective的评级 目标目标的设定一般遵循以下三个原则： 原则1：目标要明确方向且鼓舞人心目标要明确，要能引导方向，并且要有挑战，可衡量的，能激发团队的激情和斗志。有了明确的方向，事情才会有意义，多数人会因为事情的意义或者取得了进步就会感到兴奋，好的目标是能让人大清早从床上兴奋地跳起来。 原则2：目标要有时间期限比如一个月或者一个季度，要让团队明确地朝目标冲刺，如果需要一年的话，那么你的目标可能就是一个战略或者使命，没时间限制的目标那就是远大的理想了。 原则3： 由独立的团队来执行目标具体目标的执行不能是跨多个团队，这会导致目标没完成的因素多样化，比如借口是其他团队的原因，是别人没完成才导致最终目标的失败。目标必须真正属于你，没完成需承担毫无推卸的责任。 关键结果关键结果要使用那些振奋人心的语言并且需要量化，要能通过关键结果的完成判断目标是否完成，确立关键结果的一个技巧是问一个问题：“这个关键结果的达成是能进一步朝着目标前进吗？” 设置关键结果时，要给自己和团队找好定位，我们是想完成一件有挑战的事情而不是不可能完成的事情，一开始就正视50%的失败率就是最好的定位。 OKR和KPI的区别定位区别OKR是目标管理工具，KPI是考核工具，二者其实并不矛盾，甚至可以结合使用。 如果真要说区别，KPI只能让员工朝前走，而OKR用于保证人们朝正确的方向走。有些人拼命想往前走，不希望落后于别人，这时候OKR用于帮助人们少走曲线。有些人本来就不想走，这时候就需要KPI行使手段。 OKR考核“我要做的事”，KPI考核“要我做的事”，理解不同，但二者都强调有目标，同时也需要有执行力。OKR的思路是先制定目标，然后明确目标的结果，再对结果进行量化，最后考核完成情况。KPI的思路也是先确定组织目标，然后对组织目标进行分解直到个人目标，再对个人目标进行量化。 OKR和KPI两者谁都无法真正替代对方，因此谁取代谁并不重要，找到适合的方法，才是重要的事情。 评价区别OKR目标完成率在0.6-0.7之间可评定为“好”，0.4或以下才评定为“差”，（我认为这是为了要让人能够设立足够大的目标，让人不用担心100%的完成率，从而让人们敢于冒险）； 制定区别员工的OKRs是由自己制定的，员工必须自己在公司整体的OKRs和自己想达成的OKRs之间找到平衡点，由于出于自己的能力和意愿考量，可以比较大地发挥员工的主观能动性——所以，OKRs也强调，至少60%以上的OKRs必须是由下而上的。 适用场景我们的工作其实分为两类：推算型工作和探索型工作，而探索型工作更适合用OKR。 推算型工作（从1到N）：主要指根据一系列现成的指令按照某种途径达到某种结果，如商店收银台、电子配件组装等，这类工作需要的是标准化，简单的事情重复做，强调的是按时保质保量完成。推算型工作（从1到N）需要更好的管理，应该更适合采用KPI的方法。 探索型工作（从0到1）：探索型工作与推算型工作相反，必须试验各种可能性，寻求更优的解决方案，典型的如广告策划、产品研发等，这些岗位的工作不可复制，需要更好的创意，更大的创新。而在如今不稳定、不确定、复杂、模糊的时代，面对复杂、多变的商业环境，企业的巨轮说沉就沉。因此，企业必须敏捷响应外部变化，不断尝试、不断探索和突破创新，让企业的变化速度跟上甚至超过外界的变化速度，以求保持领先。因此，企业内部出现了越来越多的探索型工作，这些工作也在发挥越来越重要的价值。探索型工作（从0到1）需要灰度空间、容错能力，更适合采用OKR的方法。 比如对销售人员来讲，他们更在意如何保持持续稳定的收入，因此就需要更硬性的标准来约束销售人员完成任务，所以需要KPI而不是OKR。而对于营销团队，他们最需要将影响最大化，而过于刻板的KPI就限制了营销团队的灵活性，因此营销团队更适合OKR，而不是 KPI 。 OKR实践下面是总结的一些OKR实践方面的一些点，通过脑图呈现： 举个实际的例子，比如对于个人成长的一季度OKR: Objectives Key Results O1: 提升专业知识 KR1: 阅读完6本专业书籍，并形成6篇总结文档KR2: 每天刷1道leetcode中等算法题KR3: 向团队做三次技术分享 O2: 提升管理能力 KR1: 阅读3本管理类书籍，并向团队分享一次KR2: 完成一个管理学视频课程，并输出一篇总结文档KR3: 和直属领导谈话两次，内容限于管理经验，并输出一篇总结文档]]></content>
      <categories>
        <category>原创</category>
        <category>管理</category>
      </categories>
      <tags>
        <tag>管理</tag>
        <tag>OKR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何做好一次故障演练？]]></title>
    <url>%2Fposts%2F6fb6908f.html</url>
    <content type="text"><![CDATA[为什么要进行故障演练？伴随着海量请求、节假日峰值流量和与日俱增的系统复杂度一起出现的，很有可能是预料之中以及意料之外的各种故障。在很多情况下，由于事故处理预案的缺失或者预案本身的不可靠，以及开发人员故障处理经验的缺失，造成在各种报警之中自乱了阵脚，从而贻误了最佳战机。特别是一些平时线上没出现过的异常故障，一旦突然出现，往往措手不及。 系统是否足够健壮？是否有足够的能力应对故障的发生？当面临故障时会出现什么行为？我们并不希望真正线上出现故障时才去验证这些问题，这样风险太大，成本太大。所以希望在线上环境隔离真实流量的情况下，提前模拟产生各种任何可能发生的故障，来观察系统的反应，验证预期策略。 总结一下，故障演练主要有以下几个目标： 确保系统按我们预想的方式应对故障 寻找系统中未预料到的弱点 寻找其他提高系统鲁棒性的方式来避免事故实际发生 理想情况是达到如下流程化： 例行化故障演练、找出系统风险点、优化业务系统、产出可行有效的故障处理预案 什么是故障演练？故障演练是应用高可用能力测评的核心，一次完整的故障演练由演练的对象、对象发生的具体故障、应用的预期故障应对表现、对应用表现的实际观察和判断几部分组成。 （1）演练的对象演练的对象即演练的位置，可以针对应用本身，可以针对应用下游，也可以针对应用所在机器 （2）对象发生的具体故障常见的故障类型有以下一些： 故障类型 举例 依赖RPC服务故障 超时/不可用 中间件故障 Kafka 超时/不可用，Redis超时/不可用 基础设施故障 数据库超时/不可用，DNS 超时/不可用 机器故障 CPU 满载，网卡流量满载，网络中断，机器宕机，机房断电，磁盘空间满载 异常流量 入口流量激增，流量掉零 （3）应用的预期故障应对表现也就是预案，针对每种要演练的故障情况，制定故障应对预案，预案模板参考： 链路/场景 故障 可否演练 影响 应对预案 操作 SOP 实施预案后的影响 预案解除条件 预案解除 SOP 预案实施失败的应对方案 （4）对应用表现的实际观察和判断这个可以在监控系统上观察应用的各项指标表现，比如异常打点，流量打点，业务曲线，机器性能等一系列可能受故障影响的地方。 故障演练怎么做？故障演练前（1）检查必备基础能力 需要应用具备在业务链路中完整传递染色标记流量的能力 需要应用具备模拟下游依赖服务故障的能力 需要应用具备请求流量录制\回放\隔离的能力 （2）确定故障演练范围、环境 要对哪些请求流量注入故障？ 决策原则：选择核心业务链路的请求流量 推荐做法：链路分析，标记出核心业务链路 要模拟哪些下游服务的故障？ 决策原则：此下游服务发生故障的机率大此下游服务发生故障时影响的业务范围广此下游服务发生故障的会影响核心业务此下游服务发生故障时能制定出可行的应对方案 推荐做法：依赖链路分析，确定业务链路中依赖了哪些下游服务反向依赖分析，确定下游服务故障会影响哪些业务链路，评估影响的业务范围 在哪个应用环境模拟故障？ 决策原则：所选环境越接近线上生产环境越好 推荐做法：在线上无真实流量的机器做故障演练（关闭外部真实流量） （3）回放流量隔离和影子表隔离 流量隔离 影子表隔离 （4）制定故障应对预案针对每种要演练的故障情况，制定故障应对预案 预案制定原则：预案得有针对的故障或风险类型，可以是一个或多个得确定预案在什么情况下才能启动/解除，有什么前置要求条件预案得确实有效，即：启动预案后，确实能减小所针对故障的影响范围确定预案开启后会造成的额外影响，不能引发新的故障 （5）配置故障（6）确定演练目标 确定所制定故障应对预案确实生效，即：启动预案后，确实能减小所针对故障的影响范围 确定故障发生时期业务流程按预期运转（通过业务指标、埋点监控、相关的业务链路追踪工具确定） 确定应用机器的负载指标在预期范围内（通过各种基础工具的告警确定）（根据自身业务特点设置更多的检查点） （7）培训参与的内部人员（8）通知涉及的外部人员根据评估出的影响范围通知相关业务应用 RD、运维 RD、基础组件 RD。通知内容要素： 故障演练的发起应用 故障演练起止时间 故障演练应用集群环境 对每个相关应用的影响预估。比如：对下游依赖服务的调用峰值 QPS、上游服务收到的异常请求比率 推荐做法：将所有相关人员拉入一个工作群，群名「XXX应用故障演练」，在群里发送故障演练通知、组织协同 故障演练中 将录制的线上流量逐步加压回放到故障演练的发起应用中的无真实流量机器 开启应用的故障模拟开关，观察故障影响注意：为确保不影响真实流量，仅对染色流量发生故障 启动应用的故障应对预案 观察故障影响有无按预期消除或减小影响范围 观察各项业务指标 观察机器负载指标 验证业务流程按预期运转（比如：取消展示XX模块、不再请求YY接口） 故障演练后 现场清理 流量关闭、流量隔离任务关闭 故障模拟开关关闭、预案关闭 清理演练期间写入的数据、缓存、日志等（可选） 演练期间操作改动的业务配置开关复位 重启应用 通知相关人员演练结束 演练报告与总结 是否达到预期目标 预案有无生效 业务流程是否按预期运转 机器负载是否正常 是否有预期之外的现象发生 关键指标（业务指标、机器负载指标）收集整理 整理后续改进点 故障演练什么时候做？需要把故障以场景化的方式沉淀，以可控成本在线上模拟故障，让系统和开发人员平时有更多实战机会，加速系统、工具、流程、人员的进步。 &lt;常态化，制定演练周期&gt; 故障演练后续规划故障演练的后续工作主要会关注在以下方向：演练常态化、故障标类化、演练智能化。 用常态化的演练驱动稳定性进步，丰富更多的故障场景，定义好最小故障场景和处理手段；基于架构和业务分析的智能化演练，沉淀行业故障演练解决方案。]]></content>
      <categories>
        <category>原创</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>故障演练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM类加载机制]]></title>
    <url>%2Fposts%2F7a3ae3d8.html</url>
    <content type="text"><![CDATA[前言什么是类加载？虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型。 加载什么？前面的定义已经讲了是加载描述类的数据，也就是Class文件，关于Class文件，我在《深入解析Class类文件的结构》一文中进行了分析。 谁来加载？加载描述类的类文件的二进制流是由类加载器完成的，已有的三种类加载和自定义的类加载器组成了类加载器子系统，关于类加载器，下文会详细讲述。 怎么加载？这就是本文的重点，类加载机制中的类加载流程。可以通过下图整体上看一下类加载在JVM体系中的位置 类的生命周期类的生命周期共有7个阶段，分别如下图：前5个阶段属于类加载流程的范围，其中验证、准备、解析又被称为连接，类加载的5个阶段并不是按照顺序依次完成的，除了解析可能会在初始化之后开始，其他的几个阶段的开始顺序是确定的，但结束顺序不一定，可能会交叉着进行，加载还没完成，连接可能已经开始。 类加载流程类加载分为5个过程，分别是加载、验证、准备、解析、初始化，下面分别对这几个过程进行讲述，尽量简短明了。 加载 “加载”是”类加载”流程的一个阶段 加载阶段主要干的3件事： 通过一个类的全限定名获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class实例，作为访问入口 在这三件事里，开发人员能干预的是第一件事，我们可以使用系统的三个类加载器去加载我们想要加载的类文件，也可以自定义类加载器去获取二进制字节流。 定义类的二进制字节流不一定是经过编译后存储在磁盘上的.class文件，有可能是以下来源： 从ZIP包中读取，如：JAR、EAR、WAR 从网络中获取，如：Applet 运行时计算生成，如：动态代理技术 由其他文件生成，如：JSP文件生成.class 从数据库中读取，中间件服务器，如：SAP Netweaver Hotspot虚拟机中，Class实例不是在堆上分配空间，而是存放在方法区中，这个实例在代码中可以轻松的获取到，并通过它可以获取代表某个类的各种数据结构。 验证 验证是对输入的字节流进行检查的过程 为什么要有验证这个过程呢？就是因为加载的对象：描述类的二进制字节流，来源广泛，不得不防止它被小人利用，损害虚拟机的正常运行，导致崩溃。所以总共有四个验证过程，分别如下图： 文件格式验证这个阶段直接操作字节流，后面的三个阶段是基于方法区的存储结构，这个阶段主要是验证文件本身的字节码是不是符合规范，目的是保证输入的字节流可以被正确的存储在方法区内。上图中的四个检查项只是其中的一小部分，真正的验证点还有很多。 元数据验证这个阶段主要是验证类的元数据信息是否符合Java语言规范，比如检查是否有父类，除了Objec，其他类都应该要有父类，否则就不符合规范了；被final修饰的不允许被继承。 字节码验证这个阶段主要是对类的方法体进行验证，保证类方法的运行不会对虚拟机造成危害。这是4个验证里最复杂的一个，因为要通过数据流和控制流的分析，确定程序语义是合法的、符合逻辑的。 符号引用验证上面三个阶段是对类本身进行验证，而符号引用验证阶段主要是对类以外的信息进行验证，后面会讲到解析是将符号引用替换成直接引用，所以这里验证的目的是确保符号引用是正确的，确保后面的解析过程能顺利的进行。 准备 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段 注意这里是为类变量分配内存，而且是分配在方法区中，实例变量是后面随着实例一起分配在堆上的。 设置初始值也不是代码里赋的值，而是各个数据类型规定的零值，比如基础类型是相应类型不同字节长度的0，引用类型是null。 不是每个类变量都是设置为零值，被final修饰的常量，因为在编译期带有一个ConstantValue属性，属性值则是该常量在代码里赋的值，这个值在准备阶段前就已经确定了，所以在准备阶段设置值的时候，直接取的ConstantValue给类常量。下面的例子可以很好的了解准备阶段，准备阶段过后，a、b、c分别是多少？12345678public class Test &#123; public static int a; public static int b = 1; public static final int c = 2; public void say()&#123; System.out.println("Hello"); &#125;&#125; 答案揭晓：0, 0, 2 原因上文里写的很明白 解析 解析是将常量池内的符号引用替换为直接引用的过程 那什么是符号引用和直接引用呢？ 符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。 直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。 符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是他们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。 解析的时机根据虚拟机实现不同而不同，可以是类加载器加载时解析，也可以是符号引用使用前解析解析主要是对7类符号引用进行：类或接口、字段、类方法、接口方法、方法类型、方法句柄、调用点限定符 初始化 初始化是执行类构造器&lt;clinit&gt;()方法的过程 类初始化阶段是类加载流程的最后一个阶段，是执行&lt;clinit&gt;()方法的阶段，这个阶段才真正开始执行开发人员的代码。 &lt;clinit&gt;()方法是编译器按照源文件中定义的顺序收集类变量和静态语句块形成的方法。它的一些特点和细节如下: 编译器自动收集静态变量和静态代码块合并产生的 不需要显示的调用父类的&lt;clinit&gt;，虚拟机保证父类先执行 父类定义的静态语句块优先于子类变量赋值操作 没有静态变量和静态语句块，可以不生成&lt;clinit&gt;()方法 接口也会有这个方法，但不需要先执行父类的&lt;clinit&gt;()方法 虚拟机保证该方法在多线程环境下被正确的加锁和同步 什么时候发生初始化？对一个类进行主动引用的时候必须初始化，主动引用的场景如下： 遇到new、getstatic、putstatic、invokestatic这四条指令时 使用java.lang.reflect包的方法对类进行反射调用时 初始化一个其父类还没被初始化的类时 虚拟机启动时，包含main方法的主类还没被初始化时 当使用动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法所对应的类没有进行初始化时 什么时候不发生初始化？对一个类进行被动引用的时候不初始化，被动引用的场景有下面一些： 通过子类引用父类的静态字段，不会导致子类的初始化 通过数组定义来引用类，不会触发此类的初始化 引用类的常量时，不会触发此类的初始化 类加载器什么是类加载器？ 实现“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作的代码模块就叫做类加载器 类加载不仅仅是加载二进制字节码的作用，还起着独立的类名称空间的作用，确定一个类的唯一性由三个因素决定： 同一个java虚拟机 同一个类加载器 同一个全限定类名 双亲委派模型下图中各个加载器之间的层次关系被称为类加载器的双亲委派模型图中可以看到，系统提供了三个类加载器：启动类加载器、扩展类加载器和应用程序类加载器，java程序启动的时候，三个类加载器分别从各自指定的路径中加载所需的类。最下面是开发人员自定义的类加载器，继承自ClassLoader，重写findClass()方法。 一般我们自己写的类是默认由应用程程序加载器加载的，自定义的类加载器的父类加载器默认是应用程序加载器，应用程序加载器的父类加载器是扩展类加载器，扩展类加载器的父类加载器是启动类加载器，这种父子关系不是一般的继承或实现关系，而是子加载器持有父加载器的引用，是一种组合关系。自定义类加载器时，可以在构造函数中传入指定的父类加载器。 双亲委派模型的工作原理一个类加载器收到了类加载的请求时，它首先会先检查自身有没有加载过这个类，实质就是在JVM的常量池中查找该类的符号引用是否存在，如果有就直接返回，否则把这个请求委派给父类加载器，直至委派给启动类加载器，只有当父类加载器加载失败，子类加载器才会尝试自己去加载。 下面是实现双亲委派模型的主要代码，代码简单易懂:1234567891011121314151617181920212223242526272829303132333435363738//ClassLoader.javaprotected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; //加锁，整个类加载期间都持有锁 synchronized (getClassLoadingLock(name)) &#123; // 首先，检查此类是否已被加载过，是的话直接返回 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; //如果没有加载过，则继续 long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; //有父类加载器，则交给父类加载器加载，递归执行loadClass方法 c = parent.loadClass(name, false); &#125; else &#123; //没有父类加载器,交给启动类加载器加载，执行一个本地方法 c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // 除了启动类加载器之外的类加载器加载类失败抛异常，此处不进行任何处理 &#125; if (c == null) &#123; // 父类加载器未成功加载到类，则调用本加载器的findClass方法 long t1 = System.nanoTime(); c = findClass(name); // 记录一些状态 sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; //验证解析 if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125; 虽然易懂，但配合下面的图更容易加深理解，下面是这段代码的数据流程图：下面按照一般的双亲委派模型来分析，假设是自定义的类加载器调用了loadClass方法，触发了类加载的过程，则下面的过程会依次执行： 自定义的类加载器首先会调用findLoadedClass(name)方法查看有没有被加载的这个类，如果有直接返回，否则执行下面步骤 检查是否存在父类，如果有则递归调用父类的loadClass方法，否则说明父类加载器是启动类加载器，本类加载器是扩展类加载器，调用findBootstrapClassOrNull(name)使用启动类加载器进行类加载 启动类加载器加载成功则返回，失败则调用扩展类加载器的findClass(name)方法来加载，成功则返回，失败则继续调用应用类加载器的findClass(name)方法，同样成功返回，失败调用自定义类加载器的findClass(name) 我们自定义的类加载器一般会重写findClass方法，使用自定义的类加载器加载一个父类加载器加载不了的类的时候，就会执行自定义的findClass方法，在此方法中，会指定二进制字节码的路径读入字节数组，最后调用defineClass返回加载成功的类 下面是自定义类加载器的示例代码：12345678910111213141516171819202122232425262728293031public class MyClassLoader extends ClassLoader&#123; private String classpath; //指定父类加载器的构造函数 public MyClassLoader(String classpath,ClassLoader classLoader) &#123; super(classLoader); this.classpath = classpath; &#125; //默认父类加载器为应用程序加载器的构造函数 public MyClassLoader(String classpath) &#123; this.classpath = classpath; &#125; //重写findClass，加载类文件，返回类 @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; String classFilePath = null; String finalName = name.replace(".", "/"); classFilePath = classpath + "/" + finalName + ".class"; Path path = Paths.get(classFilePath); if (!Files.exists(path)) &#123; return null; &#125; try &#123; byte[] classData = Files.readAllBytes(path); return defineClass(name, classData, 0, classData.length); &#125; catch (IOException e) &#123; throw new RuntimeException("Can not read class file into byte array"); &#125; &#125;&#125; 为什么要使用这个模型？最后来讲讲为什么要使用这个模型？用这个模型有什么好处？ 采用双亲委派模式的好处之一是类和它对应的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关系可以避免类的重复加载，当父类加载器已经加载了该类时，子类加载器就没有必要再加载一次。 其次是考虑到安全因素，保证java核心api中定义的类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。]]></content>
      <categories>
        <category>原创</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
        <tag>类加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入解析Class类文件的结构]]></title>
    <url>%2Fposts%2F7eb7d5c7.html</url>
    <content type="text"><![CDATA[前言要深入学习Java以及Java虚拟机，深入学习Java字节码文件是绕不开的一条路，只有知道了字节码文件里的排列结构，你才能透彻的了解在JVM里，类加载是怎么加载Java类的，是怎么将二进制流转化为运行时数据结构的。 Class文件是是一组以8字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件中，中间没有任何分隔符。 这里的Class文件其实不是特指Java的字节码文件，任何编程语言的编译器只要按照字节码文件规范编译成Class文件，都可以在JVM上运行，所以字节码文件和JVM是和语言无关的。 另外一般Class文件指的不一定是存储在磁盘上的以.class后缀结束的文件，是一种泛指，指的是一切按照字节码文件规范排列的二进制字节流。 字节码文件解析Class文件采用下面这种类似C语言的结构体的伪结构来存储数据，整个Class文件是一张表，表里又由无符号数和表组成。123456789101112131415161718ClassFile &#123; u4 magic; // 魔数，固定为"0xCAFEBABY" u2 minor_version; //jdk次版本号 u2 major_version; //jdk主版本号 u2 constant_pool_count; //常量池数组大小，从1计数 cp_info constant_pool[constant_pool_count - 1]; //常量池数组 u2 access_flags; //类的访问标志，如：public u2 this_class; //类索引，指向常量池中的类符号引用 u2 super_class; //父类索引，指向常量池中的类符号引用 u2 interfaces_count; //实现的接口的数量 u2 interfaces[interfaces_count]; //接口列表，按implements后面的接口顺序 u2 fields_count; //字段数 field_info fields[fields_count]; //字段表 u2 methods_count; //方法数 method_info methods[methods_count]; //方法表 u2 attributes_count; //属性表大小 attribute_info attributes[attributes_count]; //属性表&#125; 从上面的伪结构可以看到，Class文件根据上面的顺序把规定的数据类型按照占用的字节依次排列下来。 下面通过一个例子来实战分析一下Class文件12345678//Test.classpublic class Test &#123; public static int a = 1; public static final int b = 1; public void say()&#123; System.out.println("Hello"); &#125;&#125; 上图是编译后的Test.class文件的二进制数据，可以按照上面ClassFile的结构顺序依次分析下，下面是部分分析结果：(1) u4 magic&nbsp;&nbsp;&nbsp;&nbsp;4个字节(000h:0123)魔数: 0xCAFEBABY (2) u2 minor_version&nbsp;&nbsp;&nbsp;&nbsp;2个字节(000h:45)次版本号: 0x0000, 次版本号为0 (3) u2 major_version&nbsp;&nbsp;&nbsp;&nbsp;2个字节(000h:67)主版本号: 0x0034,即52,JDK1.0-1.1：45.0 ~ 45.3, 1.1后版本增1，数字加1，所以这里用的是1.1 + 0.(52-45) = 1.8 (4) u2 constant_pool_count&nbsp;&nbsp;&nbsp;&nbsp;2个字节(000h:89)常量池大小:0x0027,即39，常量池数组是从1开始计数的，说明常量池中有38个常量，后面依次排列的就是常量池的38个常量 (5) cp_info constant_pool[constant_pool_count - 1]&nbsp;&nbsp;&nbsp;&nbsp;常量池所占的字节数是由常量池中常量的数量以及类型所决定的，这里有38个常量，每个常量开头都有一个字节的tag标识常量的类型，具体类型可以参考最下面的脑图，根据这个标识可以找到这个常量所占的字节以及含义，下面分析其中一个常量，其余的读者有兴趣可以全部完成 000h:a 0x0A,表示常量类型为10，查表可知是CONSTANT_Methodref方法符号引用，那接下来的四个字节，前两个字节表示指向常量池中方法所在类的符号引用的索引项，就是常量池的数组下标，所在的位置是方法所在类的符号引用 000h:bc 0x0007,指向常量池数组第7个元素，第7个常量是一个java.lang.Object类的符号引用 000h:de 0x0018, 指向常量池数组的第24个元素，第24个常量是一个名称和类型的符号引用，方法名是&lt;init&gt;，描述符是()V这样第一个常量就分析完成，共占5个字节，表示的是方法符号引用，该方法所在的类是Object类，方法名称是&lt;init&gt;, 无参数，返回值是void 借助工具javap可以更直观的看到我们刚刚分析的部分结果以及全部类文件的结构，使用以下命令即可：1javap -v Test.class 结果如图： 通过上面的图可以看到，和我们上面的部分分析是一致的 Class文件结构脑图下面是我在看《深入理解Java虚拟机》这本书的时候整理的关于Class文件结构的脑图，图片比较大，右键另存为图片再查看会更方便。]]></content>
      <categories>
        <category>原创</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次github提交失败的坑]]></title>
    <url>%2Fposts%2Ff587e199.html</url>
    <content type="text"><![CDATA[git push的时候出现错误：123$ blogweb git:(master) git push&gt; remote: Permission to XXX/XXX.git denied to XXX.fatal: unable to access 'https://github.com/XXX/XXX.git/': The requested URL returned error: 403 先试着把https方式换成ssh方式1234567891011121314$ vim .git/config[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true[remote "origin"] url = git@github.com:XXX/XXX.git fetch = +refs/heads/*:refs/remotes/origin/*[branch "master"] remote = origin merge = refs/heads/master 执行命令：12$ git remote set-url origin git@github.com:XXX/XXX.git$ git push 又报另一个错：12345&gt; ERROR: Permission to XXX/XXX.git denied to deploy keyfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 因为之前在本机连过github，也推过代码，一开始也没想到key的问题 最后还是去github上的设置看了下，发现竟然没加ssh keys，然后想把本地~/.ssh/id_rsa.pub里的公钥加上，结果报Error: Key already in use错误使用下面命令看看密钥用在哪儿了：12$ ssh -T -ai ~/.ssh/id_rsa git@github.com&gt; Hi XXX/XXX! You've successfully authenticated, but GitHub does not provide shell access. 发现问题了，用户名竟然是我的github名+仓库名，去github上的这个仓库看了下，还真有个key的配置，删除后，再重新配置全局的ssh keys 再执行以下命令，变正常了，push也成功了12$ ssh -T -ai ~/.ssh/id_rsa git@github.com&gt; Hi XXX! You've successfully authenticated, but GitHub does not provide shell access. 参考：https://help.github.com/en/articles/error-permission-denied-publickeyhttps://help.github.com/en/articles/error-key-already-in-use]]></content>
      <categories>
        <category>原创</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>填坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux和windows的线程机制的区别]]></title>
    <url>%2Fposts%2Fb3139f08.html</url>
    <content type="text"><![CDATA[在Linux内核中，描述一个进程主要是task_struct，一个称为进程描述符的数据结构。这个数据结构很庞大，包含了内核管理一个进程所需的所有信息，描述了一个正在执行的进程，包括进程ID，它打开的文件，进程的地址空间，挂起的信号，进程的状态等等其他信息。Linux的线程机制和Windows等其他操作系统的很不一样，Linux中没有为线程设置专门的数据结构，也没有专门的线程调度算法，在Linux内核看来，线程就是一个进程，只是一个和其他进程共享资源的特殊进程而已。 在Linux中，创建线程时，和创建普通的进程类似，每个线程都拥有自个的进程描述符task_struct，只是在调用clone()的时候需要传递一些参数标志来指明共享的资源。如图1所示。 而在windows等其他操作系统中，进程拥有一个进程描述符，描述一些地址空间和打开的文件等共享资源，进程中包含指向不同线程的指针，这些线程没有进程描述符，只描述一些少量的独有的资源，因此很轻量。同时这些线程共享进程的资源。如图2所示。]]></content>
      <categories>
        <category>原创</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>windows</tag>
        <tag>线程机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vmware+Ubuntu14.04+mininet中的host如何访问外网]]></title>
    <url>%2Fposts%2F5bd388e3.html</url>
    <content type="text"><![CDATA[最近需要mininet虚拟出的网络拓扑中的host访问外网，搞了几天，总是出些小问题，今天终于可以不出问题的搞定了。在这里总结一下，以防以后再出问题。 环境：Win7，Vmware workstation 10.0 ，Ubuntu 14.04，mininet 2.2.0 首先把宿主机win7中的VMnet8设置为自动获取IP地址，然后配置Vmware的Ubuntu，配置两块网卡，都是NAT模式。如下图： 点击确定后，点击虚拟网络编辑器，配置VMnet8的子网和掩码以及网关：我这里设置子网为10.0.0.0，子网掩码为255.255.255.0，当然也可以设置为其他的，因为是NAT模式，所以不影响其连外网。这里主要是方便后面设置主机的IP。网关设置为10.0.0.254。这里的DHCP地址范围设置随便取一个合适的范围。OK，上面的配置已经为Ubuntu配置好了网络，可以启动Ubuntu了，查看网卡信息：这个时候，ping一下，则可以ping通，而且只有通过eth0来ping通，eth1 ping不通。分别用：ping -I eth0 baidu.com 和 ping –I eth1 baidu.com测试。为了后面的需要，我们把eth1的IP设置为：0.0.0.0，这样这个闲置的网卡资源就可以被用来桥接到mininet网络中的交换机上，这个后面会介绍怎样桥接。利用命令：sudo ifconfig eth1 0.0.0.0，查看IP地址时eth1已经看不到IP地址了。好了，后面开始重点部分了，先在本地运行floodlight控制器，ip为127.0.0.1，端口为6653。然后编写python脚本创建mininet网络，如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#!/usr/bin/pythonimport reimport sysfrom mininet.cli import CLIfrom mininet.log import setLogLevel, info, errorfrom mininet.net import Mininetfrom mininet.link import Intffrom mininet.topolib import TreeTopofrom mininet.util import quietRunfrom mininet.node import OVSSwitch, OVSController, Controller, RemoteControllerfrom mininet.topo import Topo class MyTopo( Topo ):# "this topo is used for Scheme_1" def __init__( self ): "Create custom topo." # Initialize topology Topo.__init__( self ) # Add hosts h1 = self.addHost( 'h1' , ip="10.0.0.1/24", mac="00:00:00:00:00:01", defaultRoute="via 10.0.0.254") h2 = self.addHost( 'h2' , ip="10.0.0.2/24", mac="00:00:00:00:00:02", defaultRoute="via 10.0.0.254") h3 = self.addHost( 'h3' , ip="10.0.0.3/24", mac="00:00:00:00:00:03", defaultRoute="via 10.0.0.254") h4 = self.addHost( 'h4' , ip="10.0.0.4/24", mac="00:00:00:00:00:04", defaultRoute="via 10.0.0.254") # Add switches s1 = self.addSwitch( 's1' ) s2 = self.addSwitch( 's2' ) s3 = self.addSwitch( 's3' ) # Add links self.addLink( s1, s2 ) self.addLink( s1, s3 ) self.addLink( s2, h1 ) self.addLink( s2, h2 ) self.addLink( s3, h3 ) self.addLink( s3, h4 )//检查eth1或者其他指定的网卡资源是不是已经被占用def checkIntf( intf ): "Make sure intf exists and is not configured." if ( ' %s:' % intf ) not in quietRun( 'ip link show' ): error( 'Error:', intf, 'does not exist!\n' ) exit( 1 ) ips = re.findall( r'\d+\.\d+\.\d+\.\d+', quietRun( 'ifconfig ' + intf ) ) if ips: error( 'Error:', intf, 'has an IP address,' 'and is probably in use!\n' ) exit( 1 ) if __name__ == '__main__': setLogLevel( 'info' ) # try to get hw intf from the command line; by default, use eth1 intfName = sys.argv[ 1 ] if len( sys.argv ) &gt; 1 else 'eth1' info( '*** Connecting to hw intf: %s' % intfName ) info( '*** Checking', intfName, '\n' ) checkIntf( intfName ) info( '*** Creating network\n' ) net = Mininet( topo=MyTopo(),controller=None) //关键函数，创建mininet网络，指定拓扑和控制器。这里的控制器在后面添加进去 switch = net.switches[ 0 ] //取第一个交换机与eth1桥接 info( '*** Adding hardware interface', intfName, 'to switch', switch.name, '\n' ) _intf = Intf( intfName, node=switch ) //最关键的函数，用作把一个网卡与一个交换机桥接 info( '*** Note: you may need to reconfigure the interfaces for ' 'the Mininet hosts:\n', net.hosts, '\n' ) c0 = RemoteController( 'c0', ip='127.0.0.1', port=6653 ) net.addController(c0) net.start() CLI( net ) net.stop()上面的脚本运行后，在floodlight web UI中可以看到创建了如下拓扑：用上面的脚本设置了虚拟网络中的host的IP地址，MAC地址以及默认网关，然后把 Ubuntu的eth1网卡桥接到s1上，这里实现这个桥接功能主要是由Intf函数起作用，可以参看https://github.com/mininet/mininet/blob/master/examples/hwintf.py：使用 sudo python mytopo.py 运行脚本，出现mininet命令行。在命令行中使用xterm h1打开h1的独立窗口，再ping一下baidu.com。到这里就完成了host访问外网的任务了，而且在Ubuntu和win7中也都可以和host通信（ping通）。最后我根据自己的理解画了个总体的图，仅作为参考，不对的地方请留言指出，谢谢。。。 参考链接： http://techandtrains.com/2013/11/24/mininet-host-talking-to-internet/ http://www.muzixing.com/pages/2013/12/06/yuan-chuang-mininetda-jian-zi-ding-yi-wang-luo-tuo-bu-by-muzi.html]]></content>
      <categories>
        <category>原创</category>
        <category>SDN</category>
      </categories>
      <tags>
        <tag>SDN</tag>
        <tag>Mininet</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Floodligh Web UI显示的host比实际多且不会被清除的原因和解决方法]]></title>
    <url>%2Fposts%2F7d75af24.html</url>
    <content type="text"><![CDATA[每次启动完floodlight控制器，在http://127.0.0.1:8080/ui/index.html 中打开floodlight的Web UI界面后，发现host总是会比我定义的多，打开拓扑图界面也很混乱。网上查了下，说是因为OVS的一个local port会去发现外部网络的拓扑，只要禁用OVS的这个端口就可以了，有兴趣的可以试试那个方法。下面是我的实验过程及解决方法。 命令：1sudo mn --controller=remote,ip=127.0.0.1,port=6653 --topo=tree,2 如下图： 这样都分不清哪个host是我定义的，交换机倒还好，都很清晰。 所以我在用mininet创建网络拓扑的时候使用了如下命令：1sudo mn --controller=remote,ip=127.0.0.1,port=6653 --mac --topo=tree,2 多加了个mac参数，表示自动设置host的mac，会使我们的host的mac很有规律，如下图： 虽然这样还没解决主机多出来几个的问题，但至少我们能很快分清哪几个使我们的host，这时的host的mac地址，会从00:00:00:00:00:01开始分配。 1. 方法一：最后我解决host多于实际的方法是先启动mininet，再启动floodlight，因为交换机启动时，链路需要协商，如果先启动floodlight，就会把这些数据包也记录下来。所以先启动mininet，等OVS稳定下来，再启动floodlight控制器，这样就不会把OVS协商链路时发现的一些主机也记录进去。 虽然一开始，启动mininet时，不能连接上控制器，但在启动控制器后，mininet会主动与控制器连接。 还有一个问题就是，当退出mininet后，UI上的交换机会立马没了，而主机还在。 然后再用mininet创建网络，UI上的原来的host不变，host在这基础上又会增加几个，每次退出再创建都会多几个host。 上面是我重复三次这样的过程后生成的host，本来只会生成四个host，如今已越来越多。这样很烦，解决的方法是，退出mininet后，就刷新一遍网页，注意不是直接按F5刷新，这样会出错，是再输一次：http://127.0.0.1:8080/ui/index.html 按回车。这时host才会从网页中清除： 后面再创建拓扑的时候就重复上面的过程，先启动mininet，再启动floodlight，每次退出mininet，就刷新一遍网页。 2. 方法二：Google查了下发现了其他的几种方法，试了下面的方法，感觉比之前的好了，但还是有点小问题，可能只是我机子的问题。仅作参考。在floodlight的日志输出里有很多IPv6的信息。所以这个解决方法是禁用IPv6。用命令：sudo vim /etc/sysctl.conf ，然后在最后添加下面三行：123 net.ipv6.conf.all.disable_ipv6 = 1 net.ipv6.conf.default.disable_ipv6 = 1 net.ipv6.conf.lo.disable_ipv6 = 1 保存后重启电脑或者运行：sudo sysctl –p上面那种禁用IPv6的方法不一定都适用，使用其他禁用方法也可以。 3. 方法三：上面的方法二有时候不怎么好，后面我又找到了另外一种更彻底的方法：我的OVS版本是 2.0.1： Ubuntu版本是3.13: Google上说是OVS版本和Ubuntu的问题，OVS 2.0.1版本支持Ubuntu 2.6.32 到 3.10，所以我的问题出在OVS版本太低，或者Ubuntu版本过高。解决方法是升级OVS或者降低Ubuntu版本。 运行如下命令：1sudoapt-get install openvswitch-controller openvswitch-switchopenvswitch-datapath-source 把OVS更新到2.0.2： 然后问题就解决了，至少目前是解决了，彻不彻底后面再看。]]></content>
      <categories>
        <category>原创</category>
        <category>SDN</category>
      </categories>
      <tags>
        <tag>SDN</tag>
        <tag>Floodlight</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单配置bind9 的master 和slave]]></title>
    <url>%2Fposts%2F7ce23410.html</url>
    <content type="text"><![CDATA[系统：两台FreeBSD 10.1部署：一台做master，一台做slave 具体步骤如下： 首先是安装bind9，我是用的ansible远程安装的，暂时还没有把主从两个安装和配置分开，所以一开始在两台FreeBSD上安装的是一样的bind9，包括named.conf和zone文件都是一样，后面再分开配置的。 安装的过程就不赘述了，网上有很多资料，安装完后，就该分别配置两台主机使它们分别作为主从域名服务器了，其实基本配置差不多，比如options里的参数就差不多，只需要改变zone的配置。 在master中： 123456zone&quot;XXX.com&quot; IN &#123; type master; file &quot;XXX.com.zone&quot;; allow-update &#123; none; &#125;; allow-transfer &#123; &lt;slave的IP地址&gt;; &#125;; //允许被哪台slave复制数据过去&#125;; 在slave中： 12345zone &quot;XXX.com&quot; IN &#123; type slave; file &quot;slaves/XXX.com.zone&quot;; //自动创建并从master复制内容 masters &#123; &lt;master的IP地址&gt;; &#125;; //指明那台是master，可以有多台，指定多台的时候，multi-master设置为yes&#125;; Zone对应的资源文件只需要在master里编写和修改就可以了，配置好了后，分别重启服务：service named restart ，就可以看到在slave中原本没有资源文件，现在自动从master中同步过来了。当master中的zone设置了allow-transfer，且资源文件里的Serial有改变时，就会通知slave同步masters里对应地址的主域名服务器的数据。]]></content>
      <categories>
        <category>原创</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>bind9</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何编写Floodlight REST 应用]]></title>
    <url>%2Fposts%2Fb9b7a1c4.html</url>
    <content type="text"><![CDATA[可以用任何你喜欢的编程语言编写REST应用 参照步骤1、确定需求，也就是你编写的REST应用需要哪些网络服务和信息。2、检查REST API，看看是否有提供你所需的服务。 如果有，了解其RESTAPI的语法，输入的参数以及可得的选项，这样就可以直接拿来用。 如果没有，也可能是你所需的网络服务和资源信息没有提供REST API，但却可以在floodlight模块中可获得这些信息，只是没通过API暴露出来。这种情况，你可以自己实现REST API来提供你所需的服务。 如果既没有REST API，又在floodlight中找不到，那你可以自己开发floodlight Java模块，并且实现自定义的模块的REST API来提供所需的服务。 3、用所有你需要的REST API方法，设计以及组成你的应用。4、测试你的应用并且反馈给floodlight。 下面通过在floodlight/apps目录下的 python Circuit Pusher应用说明。Curcuit Pusher例子给我们展示了如何创建一个在OpenFlow集群中的两个有IP的主机A和B之间的静态单路径线路。 设计方法1、确定所需的网络服务和信息： 主机A和B的接触点，即用（交换机ID，端口）表示的数据实体，代表A和B的物理位置。 A和B之间接触点的路由，即从A经过哪个交换机和哪个端口到达B的路径 在A和B路由上所有交换机安装流量线路的服务 2、从RESTAPI中查到的可提供的信息： 从/wm/device/的GET参数获取设备的接触点信息，比如IP地址 从/wm/topology/route/////json可以获取A和B接触点之间的路由信息 用/wm/staticflowentrypusher/json的POST方法给指定的交换机安装流表项 3、应用设计： 语言使用Python 使用os.popen方法发送curl 命令来调用REST API的方法(应该还可以使用os.system) 熟悉 /wm/device语法特点，然后在命令返回的结果中解析出A和B接触点的交换机 熟悉 /wm/topology/route的语法，获取交换机和端口用来下发流表项 对于每个交换机和端口对，可以通过/wm/staticflowentrypusher/json下发流表]]></content>
      <categories>
        <category>原创</category>
        <category>SDN</category>
      </categories>
      <tags>
        <tag>SDN</tag>
        <tag>Floodlight</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Floodlight控制器的安装以及SDN环境的配置]]></title>
    <url>%2Fposts%2F96090f8a.html</url>
    <content type="text"><![CDATA[虽然网上有好多这种配置教材，但是在配置的过程中还是都会出各种问题，所以我想基于我自己的过程，记录下我的配置过程便于以后少走弯路，也给别人参考参考一下，下面的配置是我每步成功过后就记下来的，可能以后环境不是一模一样的还是会出各种小问题，这也难免。 首先在win7的VMware上安装Ubuntu14.04，并且在Ubuntu里安装一些常用到的软件1$sudo apt-get install vim,git 然后进入正式安装floodlight的环节： 安装java环境以及eclipse1$sudo apt-get install build-essentialdefault-jdk ant python-dev eclipse 下载floodlight源代码以及编译12345$ git clone git://github.com/floodlight/floodlight.git $ cd floodlight $ ant; $ sudo mkdir /var/lib/floodlight //同步数据的目录，编译完了floodlight会在这里自动生成一个SyncDB/文件夹，这行不是必需的$ sudo chmod /var/lib/floodlight 777 安装mininet1$sudo apt-get install mininet 然后可以简单测试下：1$sudo mn 可以进入mininet的命令行就表示安装成功。 运行floodlight：12$ cd floodlight$ java –jar target/floodlight.jar //控制台就打印出debug信息 运行mininet：1$sudo mn --controller=remote,ip=127.0.0.1,port=6653 这一步是把在mininet中建立的虚拟网络连接到floodlight控制器上。 查看floodlight提供的UI界面在浏览器中输入：http://127.0.0.1:8080/ui/index.html就可以看到floodlight提供的Web UI界面。在webUI中可以查看交换机，主机，流表以及网络拓扑等信息。 配置eclipse上面已经完成了基本的配置工作，但是为了方便后续的开发，我们还需要配置好eclipse，把floodlight的源代码导入到其中。方便以后给控制器添加应用模块以及查看控制器的各个模块的源代码。首先需要在floodlight的目录下执行下面这个命令：1$ant 然后打开eclipse，导入已存在的项目到工作空间，选择根目录为floodlight文件夹。 然后配置eclipse，在eclipse中右键floodlight目录，run as里面的run configurations,新建一个Java Application，name用FloodlightLaunch，project填Floodlight，main填net.floodlightcontroller.core.Main，点应用就OK了。 上面配置好了，就可以运行floodlight控制器了，点工具栏里的三角形按钮或者右键run as a JavaApplication,然后控制台就一直输出调试信息。后面就可以在eclipse中进行模块以及服务的开发。]]></content>
      <categories>
        <category>原创</category>
        <category>SDN</category>
      </categories>
      <tags>
        <tag>SDN</tag>
        <tag>Floodlight</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Floodlight控制器创建一个模块的简单过程]]></title>
    <url>%2Fposts%2F2335eb7f.html</url>
    <content type="text"><![CDATA[假设floodlight和eclipse的安装以及配置已经完成，如果还没有，请参考：https://floodlight.atlassian.net/wiki/display/floodlightcontroller/Installation+Guide 很简单的过程，大神就不用看了，主要是记下来方便自己以后用，也给需要的人参考，以下过程全部在eclipse中操作完成 在floodlight项目的src/main/java包上右键新建Java类，填上包路径和Java类名以及继承的类（继承的类一般都包括”IOFMessageListener” 和 “IFloodlightModule”），然后就会自动生成一些需要重写的函数。 为了使我们新建的这个类监听到OpenFlow消息，需要在FloodlightProvider （一个IFloodlightProviderService类）注册我们的类。 我们需要修改getModuleDependencies()函数，用来告诉模块装载器我们依赖它。getModuleDependencies()函数是第一步添加父类后自动生成的函数。 接着编写init方法，init方法在控制器启动的时候就会调用，用来加载依赖模块和初始化数据结构。 然后实现基本的监听器，在startUP方法中注册PACKET_IN消息 为OFMessage监听器加上一个ID，这步在getName()中实现 关键的一步，定义接收到PACKET_IN消息后的行为，在receive()中实现，返回Command.CONTINUE以允许这个消息继续被其他的消息处理模块接收到。 我们还需要为之前我们创建的模块注册，这样floodlight启动的时候就可以加载我们的模块，在这一步，首先我们得告诉加载器我们的模块的存在，这可以在src/main/resources/META-INF/services/net.floodlightcontroller.core.module.IFloodlightModule文件里添加我们的模块的类 最后，我们还必须在floodlight模块配置文件中添加我们创建的模块，这个是在src/main/resources/floodlightdefault.properties文件里的floodlight.modules里添加我们的包和类的全路径。]]></content>
      <categories>
        <category>原创</category>
        <category>SDN</category>
      </categories>
      <tags>
        <tag>SDN</tag>
        <tag>Floodlight</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django 外键model的互相读取]]></title>
    <url>%2Fposts%2Fd507d673.html</url>
    <content type="text"><![CDATA[先设定一个关系模型如下:1234567891011121314151617181920from django.db import modelsclass Blog(models.Model): name = models.CharField(max_length=100) tagline = models.TextField() def __str__(self): return self.name class Author(models.Model): name = models.CharField(max_length=50) email = models.EmailField() def __str__(self): return self.name class Entry(models.Model): blog = models.ForeignKey(Blog) headline = models.CharField(max_length=255) body_text = models.TextField() authors = models.ManyToManyField(Author) def __str__(self): return self.headline 上面的数据关系很明晰,Entry中有Blog和Author的外键,如果要在Entry中读取blog和author的数据很容易:1234entry = Entry.objects.all()for e in entry: blog = e.blog author = e.authors 要在Blog和Author中读取Entry也可以：12345blog = Blog.objects.all()entry = blog.entry_set.all() author = Author.objects.all()entry = author.entry_set.all() 下面通过entry使blog和author互相读取，比如要知道一个blog的Author只需如下:1234blogs = Blog.objects.all()for blog in blogs: if blog.name== “我们想要查询的博客的name” author = blog. entry_set.authors 要查询一个author的所有blog如下：1234567authors = Author.objects.all()blogs = [] for author in authors: if author.name== “我们想要查询的Author的name” for entry in author.entry_set.all(): blogs.append(entry. blog)]]></content>
      <categories>
        <category>原创</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django搭建简单网页（Form）]]></title>
    <url>%2Fposts%2F3633b975.html</url>
    <content type="text"><![CDATA[一、使用表单处理数据 为了实现投票功能，当点击某一选项时，能提交数据到vote里去处理并返回结果，需要使用表单提交数据，在之前的detail.html里写上如下代码：123456789101112#polls/templates/polls/detail.html&lt;h1&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/h1&gt;&#123;% if error_message %&#125;&lt;p&gt;&lt;strong&gt;&#123;&#123; error_message &#125;&#125;&lt;/strong&gt;&lt;/p&gt;&#123;% endif %&#125;&lt;form action="&#123;% url 'polls:vote' question.id %&#125;" method="post"&gt;&#123;% csrf_token %&#125;&#123;% for choice in question.choice_set.all %&#125; &lt;input type="radio" name="choice" id="choice&#123;&#123; forloop.counter &#125;&#125;" value="&#123;&#123; choice.id &#125;&#125;" /&gt; &lt;label for="choice&#123;&#123; forloop.counter &#125;&#125;"&gt;&#123;&#123; choice.choice_text &#125;&#125;&lt;/label&gt;&lt;br /&gt;&#123;% endfor %&#125;&lt;input type="submit" value="Vote" /&gt;&lt;/form&gt; 为了能找到vote的路径，需要在urls.py中设置路径： 12#polls/urls.pyurl(r'^(?P&lt;question_id&gt;[0-9]+)/vote/$', views.vote, name='vote'), 然后在views.py的vote函数中编写代码处理数据，实现一个问题的某一选项的票数增加并存储： 123456789101112131415161718192021#polls/views.pyfrom django.shortcuts import get_object_or_404, renderfrom django.http import HttpResponseRedirect, HttpResponsefrom django.core.urlresolvers import reversefrom .models import Choice, Question# ...def vote(request, question_id): p = get_object_or_404(Question, pk=question_id) try: selected_choice = p.choice_set.get(pk=request.POST['choice']) except (KeyError, Choice.DoesNotExist): return render(request, 'polls/detail.html', &#123; 'question': p, 'error_message': "You didn't select a choice.", &#125;) else: selected_choice.votes += 1 selected_choice.save() return HttpResponseRedirect(reverse('polls:results', args=(p.id,))) 点击投票按钮后需要跳转到投票结果页面results.html，显示某个问题的得票情况，也就是显示票数，并提示是否需要继续投票，以下代码修改view.py中的results函数，处理点击投票按钮后的数据，指定返回results.html的页面： 1234567#polls/views.pyfrom django.shortcuts import get_object_or_404, renderdef results(request, question_id): question = get_object_or_404(Question, pk=question_id) return render(request, 'polls/results.html', &#123;'question': question&#125;) 在polls的template中创建results.html，在results.html中编写如下代码： 123456789#polls/templates/polls/results.html&lt;h1&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/h1&gt;&lt;ul&gt;&#123;% for choice in question.choice_set.all %&#125; &lt;li&gt;&#123;&#123; choice.choice_text &#125;&#125; -- &#123;&#123; choice.votes &#125;&#125; vote&#123;&#123; choice.votes|pluralize &#125;&#125;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt;&lt;a href="&#123;% url 'polls:detail' question.id %&#125;"&gt;Vote again?&lt;/a&gt; 二、精简代码，使用generic views接下来，我们使用如下步骤，来转变我们之前的代码： 改变URL配置 删除一些不需要的，旧的view 引进新的，基于Django的 generic views 第一步，修改URL配置： 首先，打开polls/urls.py，作如下修改：1234567891011#polls/urls.pyfrom django.conf.urls import urlfrom . import viewsurlpatterns = [ url(r'^$', views.IndexView.as_view(), name='index'), url(r'^(?P&lt;pk&gt;[0-9]+)/$', views.DetailView.as_view(), name='detail'), url(r'^(?P&lt;pk&gt;[0-9]+)/results/$', views.ResultsView.as_view(), name='results'), url(r'^(?P&lt;question_id&gt;[0-9]+)/vote/$', views.vote, name='vote'),] 第二步，修改view，引进新的generic views：删除之前的函数，新建类引进generic view，实现之前函数实现的功能：12345678910111213141516171819202122232425#polls/views.pyfrom django.shortcuts import get_object_or_404, renderfrom django.http import HttpResponseRedirectfrom django.core.urlresolvers import reversefrom django.views import genericfrom .models import Choice, Questionclass IndexView(generic.ListView): template_name = 'polls/index.html' context_object_name = 'latest_question_list' def get_queryset(self): """Return the last five published questions.""" return Question.objects.order_by('-pub_date')[:5]class DetailView(generic.DetailView): model = Question template_name = 'polls/detail.html'class ResultsView(generic.DetailView): model = Question template_name = 'polls/results.html'def vote(request, question_id): ... # same as above]]></content>
      <categories>
        <category>原创</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django搭建简单网页（admin）]]></title>
    <url>%2Fposts%2F9a5c839.html</url>
    <content type="text"><![CDATA[一、运行后台管理 创建超级用户以便于登录到后台管理 1 python manage.py createsuperuser 接着输入用户名，邮箱，密码完成创建 运行服务程序： 1python manage.py runserver 然后在浏览器里输入：http://127.0.0.1:8000/admin/, 在登录界面完成登录就可以进入管理界面了。 为了在后台管理界面中显示我们编写的应用polls，需要在polls/admin.py中添加如下代码： 123from django.contrib import adminfrom .models import Questionadmin.site.register(Question) #在管理网页中注册需要显示的Question 这时后台会自动为Question生成一些管理表单。 为了在后台管理界面中显示我们编写的应用polls，需要在polls/admin.py中添加如下代码： 123from django.contrib import adminfrom .models import Questionadmin.site.register(Question) #在管理网页中注册需要显示的Question 这时后台会自动为Question生成一些管理表单。 二、自定义管理表单上面只是简单的注册了Question，然后让django自动生成表单。接下来要自定义表单显示的方式。 把publication date放在Question text的前面显示，还是在polls/admin.py中，只是用以下代码替代admin.site.register(Question) ： 123class QuestionAdmin(admin.ModelAdmin): fields = ['pub_date', 'question_text']admin.site.register(Question,QuestionAdmin) 同样，以后也可以自定义其他的管理对象，然后作为register()函数的第二个参数。 当Question字段太多的时候，需要把它们分开显示，这时就可以用下面的代码代替上面的代码： 123456class QuestionAdmin(admin.ModelAdmin): fieldsets = [ (None, &#123;'fields':['question_text']&#125;), ('Date information', &#123;'fields': ['pub_date']&#125;), ]admin.site.register(Question,QuestionAdmin) 一个Question对应多个Choice,所以需要将多个Choice显示在一个Question下，在polls/admin.py中用如下代码实现：123456789101112from django.contrib import adminfrom .models import Choice, Questionclass ChoiceInline(admin.StackedInline): model = Choice extra = 3class QuestionAdmin(admin.ModelAdmin): fieldsets = [ (None, &#123;&apos;fields&apos;:[&apos;question_text&apos;]&#125;), (&apos;Date information&apos;, &#123;&apos;fields&apos;: [&apos;pub_date&apos;], &apos;classes&apos;: [&apos;collapse&apos;]&#125;),#日期信息这一栏设置了可隐藏 ] inlines = [ChoiceInline]admin.site.register(Question,QuestionAdmin) 当一个问题的投票选项太多的时候，上面那样的Choice每条都比较占空间，不够简洁，如下修改ChoiceInline继承的类为TabularInline： 12 class ChoiceInline(admin.TabularInline): #... 这样每个Question下面每个Choice就分两列罗列出来，简洁明了。 关于表单的自定义，如各种元素的显示方式，都可以参考官方文档的ModelAdmin ：https://docs.djangoproject.com/en/1.8/ref/contrib/admin/#django.contrib.admin.ModelAdmin 三、自定义自己项目的template之前是django自动生成的template，从而定义的后台管理界面的风格和显示内容，现在要自己自定义自己项目的template，这样就可以在自己项目的template里修改代码，定制界面风格。根据以下步骤可以完成这个任务： 在项目目录下（即与manage.py同层次的目录）创建一个template文件夹，然后在mysite/settings.py中的DIRS选项中添加如下代码： 1&apos;DIRS&apos;:[os.path.join(BASE_DIR, &apos;templates&apos;)], 在刚创建的template文件夹下再创建admin文件夹，然后在Django的安装目录django\contrib\admin\templates\admin文件夹下，把相关的html文件复制到刚刚创建的admin下，如把admin/base_site.html复制到刚创建的admin中。 然后打开base_site.html编辑代码如下： 123&#123;%block branding %&#125;&lt;h1 id=&quot;site-name&quot;&gt;&lt;ahref=&quot;&#123;% url &apos;admin:index&apos; %&#125;&quot;&gt;PollsAdministration&lt;/a&gt;&lt;/h1&gt;&#123;% endblock %&#125; 这样标题就会变为PollsAdministration. 同理可以自定义其他的内容格式，一样的从django/admin目录里复制html文件到自己创建的admin中，修改其中的代码。]]></content>
      <categories>
        <category>原创</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django搭建简单网页（View）]]></title>
    <url>%2Fposts%2F6ad03acf.html</url>
    <content type="text"><![CDATA[一、编写前台界面views： 编写前台界面需要显示的内容，打开polls/views.py，编写如下代码：1234#polls/views.pyfrom django.http importHttpResponsedef index(request): return HttpResponse("Hello, world. You're atthe polls index.") 编写自己应用的urls文件，在应用polls下创建urls.py，添加如下代码： 1234567#polls/urls.pyfrom django.conf.urls import urlfrom . import viewsurlpatterns = [ url(r'^$', views.index, name='index'),] 在项目的urls文件里指定自己应用的urls文件，打开项目的urls.py，添加如下代码： 123456789#mysite/urls.pyfrom django.conf.urls import include, urlfrom django.contrib import adminurlpatterns = [ url(r'^polls/', include('polls.urls')), url(r'^admin/', include(admin.site.urls)),] 在浏览器中打开http://127.0.0.1:8000/polls, 就可以看到刚刚写的view，即显示“Hello,world. You’re at the polls index.” 二、编写若干个views界面同上面的原理是一样的，先写界面内容，再去自己应用的urls里面使用正则表达式指定路径。 在polls/views.py中添加如下代码： 1234567891011#polls/views.pydef detail(request, question_id): return HttpResponse("You're looking at question %s." %question_id)def results(request, question_id): response = "You're looking at the results of question %s." return HttpResponse(response % question_id)def vote(request, question_id): return HttpResponse("You're voting on question %s." %question_id) 在polls/urls.py中指定路径： 123456789101112131415#polls/urls.pyfrom django.conf.urls import urlfrom . import viewsurlpatterns = [ #ex: /polls/ url(r'^$', views.index, name='index'), #ex: /polls/5/ url(r'^(?P&lt;question_id&gt;[0-9]+)/$', views.detail, name='detail'), #ex: /polls/5/results/ url(r'^(?P&lt;question_id&gt;[0-9]+)/results/$', views.results, name='results'), #ex: /polls/5/vote/ url(r'^(?P&lt;question_id&gt;[0-9]+)/vote/$', views.vote, name='vote'),] 然后就可以在浏览器里输入各种路径，如： http://127.0.0.1:8000/polls/3: 显示“You’re looking at question 3.” http://127.0.0.1:8000/polls/3/results: 显示“You’re looking at the results ofquestion 3.” http://127.0.0.1:8000/polls/3/vote: 显示“You’re voting on question 3.” 三、编写用于显示后台数据的前台界面：上面的界面内容只是静态的显示一些字符串，接下来是实现从后台读取数据显示在前台界面 修改polls/views.py文件，其他的操作是一样的：123456789#polls/views.pyfrom django.http import HttpResponsefrom .models import Questiondef index(request): latest_question_list =Question.objects.order_by('-pub_date')[:5] output = ', '.join([p.question_text for pin latest_question_list]) return HttpResponse(output) 这里导入了models里的Question，然后读取出Question里的内容，病按日期排序。 四、从views.py中分离出template进行界面编写 在应用polls里创建templates文件夹，再在里面创建polls文件夹，在新建的polls里创建index.html文件，打开并编写如下代码： 123456789&#123;% if latest_question_list %&#125; &lt;ul&gt; &#123;% for question in latest_question_list %&#125; &lt;li&gt;&lt;a href="/polls/&#123;&#123; question.id &#125;&#125;/"&gt;&#123;&#123;question.question_text &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt;&#123;% else %&#125; &lt;p&gt;No polls are available.&lt;/p&gt;&#123;% endif %&#125; 上面代码是从views.py里分离出来的用来显示最近问题列表的功能，这里分条显示。 然后在polls的views里修改代码如下： 12345678910111213#polls/views.pyfrom django.http import HttpResponsefrom django.template import RequestContext,loaderfrom .models import Questiondef index(request): latest_question_list =Question.objects.order_by('-pub_date')[:5] template =loader.get_template('polls/index.html') context = RequestContext(request, &#123; 'latest_question_list': latest_question_list, &#125;) returnHttpResponse(template.render(context)) 这里用loader装载template：polls/index.html，然后再传递上下文给template进行render。 五、用render( )代替HttpResponse，简化代码代码修改如下：123456789#polls/views.pyfrom django.shortcuts import renderfrom .models import Questiondef index(request): latest_question_list = Question.objects.order_by('-pub_date')[:5] context = &#123;'latest_question_list': latest_question_list&#125; return render(request, 'polls/index.html', context) 这样就不用导入loader,RequestContext和HttpResponse了， render本身就是返回一个HttpResponse对象，所以直接返回。也可以这样修改更简洁：123def index(request): latest_question_list = Question.objects.order_by('-pub_date')[:5] return render(request, 'polls/index.html', &#123;'latest_question_list':latest_question_list&#125;)]]></content>
      <categories>
        <category>原创</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django搭建简单网页（models）]]></title>
    <url>%2Fposts%2F1f3cc00.html</url>
    <content type="text"><![CDATA[一、创建一个django工程 选择一个工作目录，然后用下面命令行创建一个project 1django-admin startproject mysite 创建后的目录如下所示： 1234567mysite/ manage.py mysite/ __init__.py settings.py urls.py wsgi.py 可以去mysite/settings.py中设置数据库，默认为sqlite3 使用数据库之前，得先在数据库中创建表。用如下命令： 1python manage.py migrate 启动django服务程序： 1python manage.py runserver 在浏览器中输入地址http://127.0.0.1:8000/ 就可以访问初始界面。 二、创建models 在项目目录下创建自己的app应用程序，app名为polls，使用如下命令： 1python manage.py startapp polls 则app的目录结构如下： 12345678polls/ __init__.py admin.py migrations/ __init__.py models.py tests.py views.py 在polls的models.py文件里编写代码如下： 123456789101112131415from django.dbimport modelsclassQuestion(models.Model): question_text =models.CharField(max_length=200) pub_date = models.DateTimeField(&apos;datepublished&apos;)classChoice(models.Model): question = models.ForeignKey(Question) choice_text =models.CharField(max_length=200) votes = models.IntegerField(default=0) 每个类对应数据库里的一个表，类中的成员变量对应表中的字段，即列项。 激活models，在mysite/settings.py中添加应用的名字polls，如下： 123456789INSTALLED_APPS = ( &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;, &apos;polls&apos;,) Django 知道包含了我们自己的应用polls，再用以下命令行告诉django你对models做了改变，一开始是添加了model，以后每次改变了models都要使用这条命令： 1Python manage.py makemigrations polls 再次使用 python manage.py migrate为所有的models在数据库中创建表 以后每次改变models的时候，更新数据库直接使用如下步骤：（1）在models.py改变models（2）运行命令： python manage.py makemigrations 为改变创建migration（3）运行命令：python manage.py migrate 在数据库中改变表 使用django数据库的api，打开python的shell： 1python manage.py shell 在shell中可以使用django的database api对models进行操作。 比如： 123456789101112131415161718192021222324252627282930313233343536373839&gt;&gt;&gt; from polls.models import Question, Choice &gt;&gt;&gt; Question.objects.all()[]&gt;&gt;&gt; from django.utils import timezone&gt;&gt;&gt; q = Question(question_text=&quot;What&apos;s new?&quot;,pub_date=timezone.now())# Save the objectinto the database. You have to call save() explicitly.&gt;&gt;&gt; q.save()&gt;&gt;&gt; q.id1# Access modelfield values via Python attributes.&gt;&gt;&gt; q.question_text&quot;What&apos;snew?&quot;&gt;&gt;&gt; q.pub_datedatetime.datetime(2012,2, 26, 13, 0, 0, 775217, tzinfo=&lt;UTC&gt;)# Change values bychanging the attributes, then calling save().&gt;&gt;&gt; q.question_text = &quot;What&apos;s up?&quot;&gt;&gt;&gt; q.save()# objects.all()displays all the questions in the database.&gt;&gt;&gt; Question.objects.all()[&lt;Question:Question object&gt;]]]></content>
      <categories>
        <category>原创</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
</search>
